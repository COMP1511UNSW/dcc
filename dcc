#!/usr/bin/env python3

# andrewt@unsw.edu.au May 2013-2017
# compile a C program with runtime checking enabled
# run-time errors are intercepted and an explanation
# printed in a form comprehensible to beginner programmers
# using  information obtained from  gdb
# clang errors are explained using matcher from https://github.com/cs50/help50
# This program is executed in 4 ways
#
# 1) Invoked by the user from the command line to do the compilation
#    the binary produced has code added which intercepts runtime errors and runs this program
#
# 2) invoked from the C binary when a runtime error occurs - it then runs gdb
#
# 3) invoked via gdb to print details of the program state when the runtime error occurred
#
# 4) invoked from the C binary to watch for valgrind errors on stdin when using valgrind

# The above 4 execution modes have been bundled into one file to simplify installation 

# Code needs to be Python 2 compatible for old versions of GDB
from __future__ import print_function

import collections, os, platform, re, signal, subprocess, sys, traceback


debug = int(os.environ.get('DCC_DEBUG', '0'))
dcc_path = os.path.realpath(sys.argv[0])
colorize_output = sys.stderr.isatty() or os.environ.get('DCC_COLORIZE_OUTPUT', False)

extra_c_compiler_args = "-std=gnu11 -g -lm -Wno-unused -fno-omit-frame-pointer -fno-common -funwind-tables -fno-optimize-sibling-calls -Qunused-arguments".split()

#
# Compile the user's program adding some C code
#
def compile():
    global colorize_output
    print_explanations = True  
    commandline_args = sys.argv[1:]
    if not commandline_args:
        print("Usage: %s [--valgrind|--memory|--no_explanation] <c-files>" % sys.argv[0], file=sys.stderr)
        sys.exit(1)
    for c_compiler in ["clang-3.9", "clang-3.8", "clang"]:
        if search_path(c_compiler):  # shutil.which not available in Python 2
            break
    which_sanitizer = "address"
    incremental_compilation = False
#    linking_object_files = False
    user_supplied_compiler_args = []
    for (i, arg) in enumerate(commandline_args):
        if arg in ['-u', '--undefined', '--uninitialized', '--uninitialised', '-fsanitize=memory', '--memory']:
            which_sanitizer = "memory"
            continue
        elif arg == '--valgrind':
            which_sanitizer = "valgrind"
            continue
        elif arg == '--explanation':
            print_explanations = True
            continue
        elif arg == '--no_explanation':
            print_explanations = False
            continue
        user_supplied_compiler_args.append(arg)
        if arg  == '-c':
            incremental_compilation = True
#        elif arg.endswith('.o'):
#            linking_object_files = True
        elif arg == '-fcolor-diagnostics':
            colorize_output = True
        elif arg == '-fno-color-diagnostics':
            colorize_output = False
        elif arg == '-o' and i + 1 < len(commandline_args):
            object_filename = commandline_args[i + 1]
            if object_filename.endswith('.c') and os.path.exists(object_filename):
                print("%s: will not overwrite %s with machine code" % (os.path.basename(sys.argv[0]), object_filename), file=sys.stderr)
                sys.exit(1)
    source = dcc_c_source
    source = source.replace('__DCC_PATH', '"'+dcc_path+'"')
    source = source.replace('__DCC_SANITIZER', '"'+which_sanitizer+'"')
    wrapper_source = dcc_wrapper_source
    if which_sanitizer == "memory" and platform.architecture()[0][0:2] == '32':
        if search_path('valgrind'):
            # -fsanitize=memory requires 64-bits so we fallback to embedding valgrind
            which_sanitizer = "valgrind"
        else:
            print("%s: uninitialized value checking not support on 32-bit architectures", file=sys.stderr)
            sys.exit(1)
    if which_sanitizer == "valgrind":
        sanitizer_args = []
        wrapper_source = valgrind_wrapper_source.replace('__DCC_MONITOR_VALGRIND', '"'+dcc_path+' --watch-stdin-for-valgrind-errors"')
    elif which_sanitizer == "memory":
        sanitizer_args = ['-fsanitize=memory']
    else:
        # fixme add code to check version
        if c_compiler == 'clang':
            # assume  older version of clang
            sanitizer_args = ['-fsanitize=address', '-fsanitize=undefined']
        else:
            sanitizer_args = ['-fsanitize=address', '-fsanitize=undefined', '-fno-sanitize-recover=undefined,integer']
        which_sanitizer = "address"
    if os.path.exists('/usr/bin/acc') and platform.architecture()[0][0:2] == '32':
        # backport clang-3.8 on CSE  machines needs this
        sanitizer_args +=  ['-target', 'i386-pc-linux-gnu']
    # First run  with -O enabled for better compile-time warnings 
    command = [c_compiler, '-O', '-Wall']  + sanitizer_args + extra_c_compiler_args + user_supplied_compiler_args
    if colorize_output:
        command += ['-fcolor-diagnostics']
    if debug:
        print(" ".join(command), file=sys.stderr)
    process = subprocess.Popen(command, stdin=subprocess.DEVNULL, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, close_fds=True, universal_newlines=True)
    (output) = process.communicate()[0]
    if output:
        # remove any ANSI codes
        # http://stackoverflow.com/a/14693789
        colourless_output = re.sub(r'\x1b[^m]*m', '', output)
        lines = output.splitlines()
        colourless_lines = colourless_output.splitlines()
        messages_explained = 0
        try:
            i = 0
            explanation_made = {}
            last_explanation_file_line = ''
            while i < len(lines) and print_explanations:
                matching_error_messages = help_dcc(colourless_lines[i:]) or help(colourless_lines[i:])
                if not matching_error_messages: 
                    break
                matched_error_messages, explanation = matching_error_messages
                # ignore some I don't know explanations
                if re.match(r'not quite sure', explanation[0], flags=re.I):
                    break
                explanation = "\n ".join([e for e in explanation if 'cs50' not in e])
                explanation = explanation.replace("`clang`", 'the compiler')
                # Don't repeat explanations
                n_explained_lines = len(matched_error_messages)
                # some help messages miss the caret
                if (n_explained_lines == 1 or  n_explained_lines == 2) and len(lines) > i + 2 and has_caret(colourless_lines[i+2]):
                    n_explained_lines = 3
                if len(lines) > i + n_explained_lines and re.match(r'^.*note:', colourless_lines[i + n_explained_lines]):
                    #print('note line detcted')
                    n_explained_lines += 1
                e = re.sub('line.*', '', explanation, flags=re.I)
                if e not in explanation_made:
                    explanation_made[e] = 1
                    m = re.match(r'^([^:]+:\d+):', colourless_lines[i])
                    if m:
                        if m.group(1) == last_explanation_file_line:
                            # stop if there are two errors for one line - the second is probably wrong
                            break
                        last_explanation_file_line = m.group(1)
                    print("\n".join(lines[i:i+n_explained_lines]),  file=sys.stderr)
                    if colorize_output:
                        print("\033[0m\033[34mEXPLANATION:\033[0m", explanation+'\n', file=sys.stderr)
                    else:
                        print("EXPLANATION:", explanation+'\n', file=sys.stderr)
                    messages_explained = messages_explained + 1
                i += n_explained_lines
                if messages_explained >= 3:
                    break
            if not messages_explained:
                sys.stderr.write(output)
        except Exception:
            etype, evalue, etraceback = sys.exc_info()
            eformatted = "\n".join(traceback.format_exception_only(etype, evalue))
            print("%s: internal error: %s" % (os.path.basename(sys.argv[0]), eformatted), file=sys.stderr)
            sys.stderr.write(output)
        if process.returncode:
            sys.exit(process.returncode)
    # run a second time without -O for better debugging code
    command = [c_compiler, '-w'] + sanitizer_args + extra_c_compiler_args + user_supplied_compiler_args
    if incremental_compilation:
        if debug:
            print(" ".join(command), file=sys.stderr)
        sys.exit(subprocess.call(command))
    if c_compiler != 'clang':  
        command +=  ['-Wl,-wrap,main', '-x', 'c', '-']
    if debug:
        print(" ".join(command), file=sys.stderr)
    if debug > 1:
        print(" ".join(command), '<<eof', file=sys.stderr)
        print(source + wrapper_source)
        print("eof")
    p = subprocess.Popen(command, stdin=subprocess.PIPE)
    p.communicate(input=(source + wrapper_source).encode('utf8'))
    sys.exit(p.wait())

def search_path(program):
    for path in os.environ["PATH"].split(os.pathsep):
        full_path = os.path.join(path, program)
        if os.path.isfile(full_path) and os.access(full_path, os.X_OK):
            return full_path

#
# C code to intercept runtime errors and run this program
#

dcc_c_source = r"""
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <assert.h>
#include <string.h>
#include <signal.h>
#include <limits.h>
#include <errno.h>

static int debug = 0;

static void _dcc_exit(void) {
    if (debug) fprintf(stderr, "_dcc_exit()\n");
    // exit or _exit keeps executing sanitizer code - including perhaps superfluous output
    // SIGPIPE avoids killed message from bash
    signal(SIGPIPE, SIG_DFL);
    kill(getpid(), SIGPIPE);
    signal(SIGINT, SIG_DFL);
    kill(getpid(), SIGINT);
    // if SIGINT fails
    kill(getpid(), SIGKILL);
    // should never reach here
    _exit(1);
}

static void setenvd(char *n, char *v) {
    setenv(n, v, 1);
    if (debug) fprintf(stderr, "setenv %s=%s\n", n, v);
}

static void _explain_error(void) {
    if (debug) fprintf(stderr, "running %s\n", __DCC_PATH);
    system(__DCC_PATH);
    _dcc_exit();
}

static void _signal_handler(int signum) {
    signal(SIGABRT, SIG_IGN);
    signal(SIGSEGV, SIG_IGN);
    signal(SIGINT, SIG_IGN);
    signal(SIGXCPU, SIG_IGN);
    signal(SIGXFSZ, SIG_IGN);
    signal(SIGFPE, SIG_IGN);
    signal(SIGILL, SIG_IGN);
    char signum_buffer[1024];
    sprintf(signum_buffer, "%d", (int)signum);
    setenvd("DCC_SIGNAL", signum_buffer);
    _explain_error();
}

void __dcc_start(void) __attribute__((constructor));

void __dcc_start(void) {
    debug = getenv("DCC_DEBUG") != NULL;
    if (debug) fprintf(stderr, "__dcc_start\n");
    debug = getenv("DCC_DEBUG") != NULL;
    setenvd("DCC_SANITIZER", __DCC_SANITIZER);
    setenvd("DCC_PATH", __DCC_PATH);
    char pid_buffer[1024];
    sprintf(pid_buffer, "%d", (int)getpid());
    setenvd("DCC_PID", pid_buffer);
    signal(SIGABRT, _signal_handler);
    signal(SIGSEGV, _signal_handler);
    signal(SIGINT, _signal_handler);
    signal(SIGXCPU, _signal_handler);
    signal(SIGXFSZ, _signal_handler);
    signal(SIGFPE, _signal_handler);
    signal(SIGILL, _signal_handler);
}

// intercept ASAN explanation
void _Unwind_Backtrace(void *a, ...) {
    if (debug) fprintf(stderr, "_Unwind_Backtrace\n");
    _explain_error();
}


// intercept ASAN explanation
void __asan_on_error() {
    if (debug) fprintf(stderr, "__asan_on_error\n");
    setenvd("DCC_ASAN_ERROR", "1");
    _explain_error();
}

char *__ubsan_default_options() {
    return "verbosity=0:print_stacktrace=1:halt_on_error=1:detect_leaks=0";
}

char *__asan_default_options() {
    return "verbosity=0:print_stacktrace=1:halt_on_error=1:detect_leaks=0";
}

char *__msan_default_options() {
    return "verbosity=0:print_stacktrace=1:halt_on_error=1:detect_leaks=0";
}
""" 

dcc_wrapper_source = r""" 
int __wrap_main(int argc, char *argv[], char *envp[]) {
    extern int __real_main(int argc, char *argv[]);
    int i;
    char mypath[PATH_MAX];
    realpath(argv[0], mypath);
    setenvd("DCC_BINARY", mypath);
    return __real_main(argc, argv);
}
""" 

valgrind_wrapper_source = r""" 
int __wrap_main(int argc, char *argv[], char *envp[]) {
    extern int __real_main(int argc, char *argv[]);
    int i;
    char mypath[PATH_MAX];
    realpath(argv[0], mypath);
    setenvd("DCC_BINARY", mypath);
    int valgrind_running = getenv("DCC_VALGRIND_RUNNING") != NULL;
    if (debug) printf("__wrap_main(valgrind_running=%d)\n", valgrind_running);
    if (valgrind_running) {
        // valgrind errors get reported earlier if we unbuffer stdout
        // otherwise uninitialized variables may not be detected until fflush when program exits
        // which produces poor error message
        setbuf(stdout, NULL);          
        signal(SIGPIPE, SIG_DFL);
        if (debug) printf("running __real_main\n");
        return __real_main(argc, argv);
    }
    if (debug) fprintf(stderr, "command=%s\n", __DCC_MONITOR_VALGRIND);
    FILE *valgrind_error_pipe = popen(__DCC_MONITOR_VALGRIND, "w");
    setbuf(valgrind_error_pipe, NULL);          
    setenvd("DCC_VALGRIND_RUNNING", "1");
    char fd_buffer[1024];
    sprintf(fd_buffer, "--log-fd=%d", (int)fileno(valgrind_error_pipe));
//  char *valgrind_command[] = {"/usr/bin/valgrind", "-q", "--vgdb=yes", "--max-stackframe=16000000", fd_buffer, "--track-origins=yes", "--vgdb-error=1"};
    char *valgrind_command[] = {"/usr/bin/valgrind", "-q", "--vgdb=yes", "--max-stackframe=16000000", "--partial-loads-ok=no", fd_buffer, "--vgdb-error=1"};
    int valgrind_command_len = sizeof valgrind_command / sizeof valgrind_command[0];
    char *valgrind_argv[argc + 1 + valgrind_command_len];
    for (i = 0; i < valgrind_command_len; i++)
        valgrind_argv[i] = valgrind_command[i];
    valgrind_argv[valgrind_command_len] = argv[0];
    for (i = 1; i < argc; i++)
        valgrind_argv[i+valgrind_command_len] = argv[i];
    valgrind_argv[argc+valgrind_command_len] = NULL;
    execvp("/usr/bin/valgrind", valgrind_argv);
    return 0;
}
""" 
#
# some extra helpers 

def help_dcc(lines):
    # $ clang foo.c
    # /tmp/foo-1ce1b9.o: In function `main':
    # foo.c:5:19: warning: format specifies type 'int *' but the argument has type 'int' [-Wformat]
    #    printf("%d\n", "hello!");
    #            ~~     ^~~~~~~~
    #            %s
    # TODO: pattern match on argument's type
    matches = match(r"format specifies type '(?P<type>int|double) \*' but the argument has type '(?P=type)'", lines[0])
    if matches:
        argument = caret_extract(lines[1:3])
        if argument and re.match(r'^[a-zA-Z]', argument):
            response = [
                "Perhaps you have forgotten an `&` before the argument `{}` on line {} of `{}`.".format(argument, matches.line, matches.file)
            ]
            if len(lines) >= 4 and re.search(r"%", lines[3]):
                return (lines[0:4], response)
            return (lines[0:3], response)
    # $ clang foo.c
    # /tmp/foo-1ce1b9.o: In function `main':
    # foo.c:5:19: error: format specifies type 'int' but the argument has type 'char *' [-Werror,-Wformat]
    #    printf("%d\n", "hello!");
    #            ~~     ^~~~~~~~
    #            %s
    # TODO: pattern match on argument's type
    matches = match(r"format specifies type '[^:]+' but the argument has type '[^:]+'", lines[0])
    if matches:
        response = [
            "Be sure to use the correct format code (e.g., `%d` for integers, `%lf` for floating-point values) in your format string on line {} of `{}`.".format(matches.line, matches.file)
        ]
        if len(lines) >= 3 and re.search(r"\^", lines[2]):
            if len(lines) >= 4 and re.search(r"%", lines[3]):
                return (lines[0:4], response)
            return (lines[0:3], response)
        return (lines[0:1], response)
    # $ clang foo.c
    # /usr/bin/../lib/gcc/x86_64-linux-gnu/6.3.0/../../../x86_64-linux-gnu/crt1.o: In function `_start':
    # (.text+0x20): undefined reference to `main'
    # clang: error: linker command failed with exit code 1 (use -v to see invocation)
    if lines[1:] and re.search(r"undefined reference to `main'", lines[1]):
        response = [
            "Your program does not contain a main function - a C program must contain a main function."
        ]
        return (lines, response)
    # $ clang a.c b.c
    # /tmp/b-9a488a.o: In function `main':
    # /home/andrewt/b.c:1: multiple definition of `main'
    # /tmp/a-583396.o:/home/andrewt/a.c:1: first defined here
    # clang: error: linker command failed with exit code 1 (use -v to see invocation)
    if lines[1:] and re.search(r"multiple definition of `main'", lines[1]):
        response = [
            "Your program contains more than one main function - a C program can only contain one main function."
        ]
        return (lines, response)

#
# following code from
# https://github.com/cs50/help50/blob/master/helpers/clang.py
from collections import namedtuple

def help(lines):

    # $ clang foo.c
    # foo.c:13:25: error: adding 'int' to a string does not append to the string [-Werror,-Wstring-plus-int]
    matches = match(r"adding '(.+)' to a string does not append to the string", lines[0])
    if matches:
        response = ["Careful, you can't concatenate values and strings in C using the `+` operator, as you seem to be trying to do on line {} of `{}`.".format(matches.line, matches.file)]
        if len(lines) >= 2 and re.search(r"printf\s*\(", lines[1]):
            response.append("Odds are you want to provide `printf` with a format code for that value and pass that value to `printf` as an argument.")
            return (lines[0:2], response)
        return (lines[0:1], response)

    # caesar.c:9:18: error: array index 1 is past the end of the array (which contains 1 element) [-Werror,-Warray-bounds]
    #    int k = atoi(argv[1]);
    #                 ^    ~
    matches = match(r"array index (\d+) is past the end of the array", lines[0])
    if matches:
        array = caret_extract(lines[1:3])
        if array:
            response = ["Careful, on line {} of `{}`, it looks like you're trying to access location {} of `{}`, which doesn't exist; `{}` isn't that long.".format(matches.line, matches.file, matches.group[0], array, array)]
        else:
            response = ["Careful, on line {} of `{}`, it looks like you're trying to access location {} of an array, which doesn't exist; the array isn't that long.".format(matches.line, matches.file, matches.group[0])]
        response.append("Keep in mind that arrays are 0-indexed.")
        if array:
            return (lines[0:3], response)
        return (lines[0:1], response)

    # $ clang foo.c
    # foo.c:6:21: error: array subscript is not an integer
    #     printf("%i\n", x["28"]);
    #                     ^~~~~
    matches = match(r"array subscript is not an integer", lines[0])
    if matches:
        array = caret_extract(lines[1:3], left_aligned=False)
        index = tilde_extract(lines[1:3])
        if array and index:
            response = [
                "Looks like you're trying to access an element of the array `{}` on line {} of `{}`, but your index (`{}`) is not of type `int`.".format(array, matches.line, matches.file, index)
            ]
            if index.startswith("\"") and index.endswith("\""):
                response.append("Right now, your index is of type `string` instead.")
        else:
            response = [
                "Looks like you're trying to access an element of an array on line {} of `{}`, but your index is not of type `int`.".format(matches.line, matches.file)
            ]
        response.append("Make sure your index (the value between square brackets) is an `int`.")
        if len(lines) >= 2 and re.search(r"[.*]", lines[1]):
            return (lines[0:2], response)
        return (lines[0:1], response)

    # $ clang foo.c
    # foo.c:1:3: error: assigning to 'float' from incompatible type 'float (void)'
    #         f = get_float;
    #           ^ ~~~~~~~~~
    matches = match(r"assigning to '(.+)' from incompatible type '.+ \(.+\)'", lines[0])
    if matches:
        function = tilde_extract(lines[1:3])
        if function:
            response = [
                "Looks like you're trying to call `{}` on line {} of `{}`, but did you forget parentheses after the function's name?".format(function, matches.line, matches.file)
            ]
            return (lines[0:3], response);
        else:
            response = [
                "Looks like you're trying to call a function on line {} of `{}`, but did you forget parentheses after the function's name?".format(matches.line, matches.file)
            ]
            return (lines[0:1], response);

    # $ clang foo.c
    # /tmp/foo-1ce1b9.o: In function `main':
    # foo.c:3:12: error: conflicting types for 'round'
    # int round(int n);
    #     ^
    matches = match(r"conflicting types for '(.*)'", lines[0])
    if matches:
        response = [
            "Looks like you're redeclaring the function `{}`, but with a different return type on line {} of `{}`.".format(matches.group[0], matches.line, matches.file)
        ]
        if len(lines) >= 4:
            new_matches = re.search(r"^([^:]+):(\d+):\d+: note: previous declaration is here", lines[3])
            if new_matches:
                if matches.file == new_matches.group(1):
                    response.append("You had already declared this function on line {}.".format(matches.line))
                else:
                    response.append("The function `{}` is already declared in the library {}. Try renaming your function.".format(matches.group[0], new_matches.group(1).split('/')[-1]))
                return(lines[0:4], response)
        return (lines[0:1], response)

    # $ clang foo.c
    # test.c:51:17: error: 'continue' statement not in loop statement
    #                 continue;
    #                 ^
    matches = match(r"'continue' statement not in loop statement", lines[0])
    if matches:
        response = [
            "Looks like you're trying to use `continue` on line {} of `{}`, which isn't inside of a loop, but that keyword can only be used inside of a loop.".format(matches.line, matches.file)
        ]
        return (lines[0:1], response)

    # $ clang foo.c
    # /tmp/foo-1ce1b9.o: In function `main':
    # foo.c:6:1: error: control reaches end of non-void function [-Werror,-Wreturn-type]
    #
    # $ clang foo.c
    # /tmp/foo-1ce1b9.o: In function `main':
    # foo.c:7:1: error: control may reach end of non-void function [-Werror,-Wreturn-type]
    matches = match(r"control (may )?reach(es)? end of non-void function", lines[0])
    if matches:
        response = ["Ensure that your function will always return a value. If your function is not meant to return a value, try changing its return type to `void`."]
        return (lines[0:1], response)

    # $ clang foo.c
    # /tmp/foo-1ce1b9.o: In function `main':
    # foo.c:5:29: error: data argument not used by format string [-Werror,-Wformat-extra-args]
    #    printf("%d %d", 27, 28, 29);
    #           ~~~~~~~          ^
    matches = match(r"data argument not used by format string", lines[0])
    if matches:
        response = [
            "You have more arguments in your formatted string on line {} of `{}` than you have format codes.".format(matches.line, matches.file),
            "Make sure that the number of format codes equals the number of additional arguments.",
            "Try either adding format code(s) or removing argument(s)."
        ]
        if len(lines) >= 2 and re.search(r"%", lines[1]):
            return (lines[0:2], response)
        return (lines[0:1], response)

    # $ clang foo.c
    # /tmp/foo-1ce1b9.o: In function `main':
    # foo.c:6:8: error: declaration shadows a local variable [-Werror,-Wshadow]
    #    int x = 28;
    #        ^
    # foo.c:5:13: note: previous declaration is here
    #               int x = 2;
    #                   ^
    #
    # $ clang foo.c
    # /tmp/foo-1ce1b9.o: In function `main':
    # foo.c:5:20: error: declaration shadows a local variable [-Werror,-Wshadow]
    #    for (int i = 0, i < 28, i++)
    #                    ^
    matches = match(r"declaration shadows a local variable", lines[0])
    if matches:
        response = [
            "On line {} of `{}`, it looks like you're trying to declare a variable that's already been declared elsewhere.".format(matches.line, matches.file)
        ]

        # check to see if declaration shadowing is due to for loop with commas instead of semicolons
        if len(lines) >= 2:
            for_loop = re.search(r"^\s*for\s*\(", lines[1])
            if for_loop:
                response.append("If you meant to create a `for` loop, be sure that each part of the `for` loop is separated with a semicolon rather than a comma.")
                if (len(lines) >= 3 and re.search(r"^\s*\^$", lines[2])):
                    return (lines[0:3], response)
                return (lines[0:2], response)

        # see if we can get the line number of the previous declaration of the variable
        prev_declaration_file = None
        prev_declaration_line = None
        if len(lines) >= 4:
            prev = re.search(r"^([^:]+):(\d+):\d+: note: previous declaration is here", lines[3])
            if prev:
                prev_declaration_line = prev.group(2)
                prev_declaration_file = prev.group(1)

        omit_suggestion = "If you meant to use the variable you've already declared previously"
        if prev_declaration_line and prev_declaration_file:
            omit_suggestion += " (on line {} of `{}`)".format(prev_declaration_line, prev_declaration_file)
        omit_suggestion += ", try getting rid of the data type of the variable on line {} of `{}`. You only need to include the data type when you first declare a variable.".format(matches.line, matches.file)
        response.append(omit_suggestion)
        response.append("Otherwise, if you did mean to declare a new variable, try changing its name to a name that hasn't been used yet.")

        if len(lines) >= 4 and prev_declaration_line != None:
            return (lines[0:7], response) if len(lines) >= 6 and re.search(r"^\s*\^$", lines[5]) else (lines[0:4], response)
        if len(lines) >= 2:
            return (lines[0:2], response)
        return (lines[0:1], response)

    # $ clang foo.c
    # /tmp/foo-1ce1b9.o: In function `main':
    # foo.c:5:16: error: division by zero is undefined [-Werror,-Wdivision-by-zero]
    # int x = 28 / 0;
    #            ^ ~
    matches = match(r"division by zero is undefined", lines[0])
    if matches:
        response = [
            "Looks like you're trying to divide by `0` (which isn't defined mathematically) on line {} of `{}`.".format(matches.line, matches.file)
        ]
        if len(lines) >= 2:
            return (lines[0:2], response)
        else:
            return (lines[0:1], response)

    # $ clang foo.c
    # /tmp/foo-1ce1b9.o: In function `main':
    # foo.c:9:2: error: expected '}'
    # }
    #  ^
    matches = match(r"expected '}'", lines[0])
    if matches:
        response = ["Make sure that all opening brace symbols `{` are matched with a closing brace `}`."]
        return (lines[0:1], response)

    # $ clang foo.c
    # /tmp/foo-1ce1b9.o: In function `main':
    # foo.c:6:8: error: expected '(' after 'if'
    #     if x == 28
    #        ^
    matches = match(r"expected '\(' after 'if'", lines[0])
    if matches:
        response = [
            "In your `if` statement on line {} of `{}`, be sure that you're enclosing the condition you're testing within parentheses.".format(matches.line, matches.file)
        ]
        if len(lines) >= 2 and re.search(r"if\s*\(", lines[1]):
            return (lines[0:2], response)
        return (lines[0:1], response)

    # $ clang foo.c
    # /tmp/foo-1ce1b9.o: In function `main':
    # foo.c:6:1: error: expected ')'
    # }
    # ^
    matches = match(r"expected '\)'", lines[0])
    if matches:
        # assume that the line number for the matching ')' is the line that generated the error
        match_line = matches.line
        n = 1

        # if there's a note on which '(' to match, use that line number instead
        if (len(lines) >= 4):
            parens_match = re.search(r"^([^:]+):(\d+):\d+: note: to match this '\('", lines[3])
            if parens_match:
                match_line = parens_match.group(2)
                n = 4

        response = [
            "Make sure that all opening parentheses `(` are matched with a closing parenthesis `)` in `{}`.".format(matches.file),
            "In particular, check to see if you are missing a closing parenthesis on line {} of `{}`.".format(match_line, matches.file)
        ]
        return (lines[0:n], response)

    # $ clang foo.c
    # /tmp/foo-1ce1b9.o: In function `main':
    # foo.c:5:27: error: expected ';' after expression
    #    printf("hello, world!")
    #                           ^
    #                           ;
    matches = match(r"expected ';' (?:after expression|at end of declaration|after do\/while statement)", lines[0])
    if matches:
        response = ["Try including a semicolon at the end of line {} of `{}`.".format(matches.line, matches.file)]
        if len(lines) >= 3 and re.search(r"^\s*\^$", lines[2]):
            if len(lines) >= 4 and re.search(r"^\s*;$", lines[3]):
                return (lines[0:4], response)
            return (lines[0:3], response)
        return (lines[0:1], response)

    # $ clang foo.c
    # /tmp/foo-1ce1b9.o: In function `main':
    # foo.c:5:22: error: expected ';' in 'for' statement specifier
    #    for (int i = 0, i < 28, i++)
    #                      ^
    matches = match(r"expected ';' in 'for' statement specifier", lines[0])
    if matches:
        response = ["Be sure to separate the three components of the 'for' loop on line {} with semicolons.".format(matches.file)]
        if len(lines) >= 2 and re.search(r"for\s*\(", lines[1]):
            return (lines[0:2], response)
        return (lines[0:1], response)

    # $ clang foo.c
    # /tmp/foo-1ce1b9.o: In function `main':
    # foo.c:28:28: error: expected expression
    matches = match(r"expected expression", lines[0])
    if matches:
        response = [
            "Not quite sure how to help, but focus your attention on line {} of `{}`!".format(matches.line, matches.file)
        ]
        return (lines[0:1], response)

    # mario.c:8:16: error: expected identifier
    # if (i<23)&&(i>0)
    #            ^
    # 1 error generated.
    # make: *** [mario] Error 1
    matches = match(r"expected identifier", lines[0])
    if matches:
        response = [
            "Not quite sure how to help, but focus your attention on line {} of `{}`!".format(matches.line, matches.file)
        ]
        if (len(lines) >= 3 and has_caret(lines[2])):
            return (lines[0:3], response)
        else:
            return (lines[0:1], response)

    # $ clang foo.c
    # /tmp/foo-1ce1b9.o: In function `main':
    # foo.c:5:1: error: expected identifier or '('
    # do
    # ^
    matches = match(r"expected identifier or '\('", lines[0])
    if matches:
        response = [
            "Looks like `clang` is having some trouble understanding where your functions start and end in your code.",
            "Are you defining a function (like `main` or some other function) somewhere just before line {} of `{}`?".format(matches.line, matches.file),
            "If so, make sure the function's first line doesn't end with a semicolon.",
            "Also make sure that all of the code for your function is inside of curly braces."
        ]
        return (lines[0:1], response)

    # $ clang foo.c
    # /tmp/foo-1ce1b9.o: In function `main':
    # foo.c:3:12: error: expected parameter declarator
    # int square(28);
    #            ^
    matches = match(r"expected parameter declarator", lines[0])
    if matches:
        response = [
            "If you're trying to call a function on line {} of `{}`, be sure that you're calling it inside of curly braces within a function. Also check that the function's header (the line introducing the function's name) doesn't end in a semicolon.".format(matches.line, matches.file),
            "Alternatively, if you're trying to declare a function or prototype on line {} of `{}`, be sure each argument to the function is formatted as a data type followed by a variable name.".format(matches.line, matches.file)
        ]
        if len(lines) >= 3 and re.search(r"^\s*\^$", lines[2]):
            return (lines[0:3], response)
        return (lines[0:1], response)

    # $ clang foo.c
    # /tmp/foo-1ce1b9.o: In function `main':
    # foo.c:9:1: error: expected 'while' in do/while loop
    # }
    # ^
    matches = match(r"expected 'while' in do/while loop", lines[0])
    if matches:
        response = [
            "Looks like you're trying to create a `do/while` loop, but you've left off the `while` statement.",
            "Try adding `while` followed by a condition just before line {} of `{}`.".format(matches.line, matches.file)
        ]
        return (lines[0:1], response)

    # $ clang foo.c
    # foo.c:6:16: error: expression result unused [-Werror,-Wunused-value]
    # n*12;
    #  ^ 1 error generated.
    matches = match(r"expression result unused", lines[0])
    if matches:
        response = [
            "On line {} of `{}` you are performing an operation, but not saving the result.".format(matches.line, matches.file),
            "Did you mean to print or store the result in a variable?"
        ]
        return (lines[0:1], response)

    # $ clang foo.c
    # /tmp/foo-1ce1b9.o: In function `main':
    # foo.c:1:19: error: extra tokens at end of #include directive [-Werror,-Wextra-tokens]
    # #include <stdio.h>;
    #                   ^
    matches = match(r"extra tokens at end of #include directive", lines[0])
    if matches:
        response = [
            "You seem to have an error in `{}` on line {}.".format(matches.file, matches.line),
            "By \"extra tokens\", `clang` means that you have one or more extra characters on that line that you shouldn't."
        ]
        if len(lines) >= 3 and re.search(r"^\s*\^", lines[2]):
            token = lines[1][lines[2].index("^")]
            if token == ";":
                response.append("Try removing the semicolon at the end of that line.")
            else:
                response.append("Try removing the `{}` at the end of that line.".format(token))
            return (lines[0:2], response)
        return (lines[0:1], response)

    # $ clang foo.c
    # /tmp/foo-1ce1b9.o: In function `main':
    # foo.c:1:19: error: extraneous ')' before ';' [-Werror]
    # digit = (number % (tracker)) / (tracker/10));
    #                                            ^
    matches = match(r"extraneous '\)' before ';'", lines[0])
    if matches:
        response = [
            "You seem to have an extra parenthesis on line {} of `{}`, just before the semicolon.".format(matches.line, matches.file)
        ]
        if len(lines) >= 3 and has_caret(lines[2]):
            return (lines[0:3], response)
        else:
            return (lines[0:1], response)

    # $ clang foo.c
    # /tmp/foo-1ce1b9.o: In function `main':
    # foo.c:21:1: error: extraneous closing brace ('}')
    # }
    # ^
    matches = match(r"extraneous closing brace \('}'\)", lines[0])
    if matches:
        response = [
            "You seem to have an unnecessary `}}` on line {} of `{}`.".format(matches.line, matches.file)
        ]
        if len(lines) >= 3 and re.search(r"^\s*\^\s*$", lines[2]):
            return (lines[0:3], response)
        else:
            return (lines[0:1], response)

    # $ clang foo.c
    # /tmp/foo-1ce1b9.o: In function `main':
    # foo.c:1:10: fatal error: 'studio.h' file not found
    # #include <studio.h>
    #          ^
    matches = match(r"'(.*)' file not found", lines[0])
    if matches:
        response = [
            "Looks like you're trying to `#include` a file (`{}`) on line {} of `{}` which does not exist.".format(matches.group[0], matches.line, matches.file)
        ]
        if matches.group[0] in ["studio.h"]:
            response.append("Did you mean to `#include <stdio.h>` (without the `u`)?")
        else:
            response.append("Check to make sure you spelled the filename correctly.")

        if len(lines) >= 2 and re.search(r"#include", lines[1]):
            return (lines[0:2], response)
        return (lines[0:1], response)

    # $ clang foo.c
    # foo.c:6:16: error: format string is not a string literal (potentially insecure) [-Werror,-Wformat-security]
    # printf(c);
    # ^ 1 error generated.
    matches = match(r"format string is not a string literal", lines[0])
    if matches and len(lines) >= 3 and re.search(r"^\s*\^", lines[2]):
        line = matches.line
        file = matches.file
        matches = re.search(r"^(.?printf|.?scanf)\s*\(", lines[1][lines[2].index("^"):])
        print(lines[1][lines[2].index("^"):])
        if matches:
            response = ["The first argument to `{}` on line {} of `{}` should be a double-quoted string.".format(matches.group(1), line, file)]
            return (lines[0:2], response)

    # $ clang foo.c
    # /tmp/foo-1ce1b9.o: In function `main':
    # foo.c:7:15: error: expression is not an integer constant expression
    #         case (x > 28):
    #              ~^~~~~~~
    matches = match(r"expression is not an integer constant expression", lines[0])
    if matches:
        response = [
            "Remember that each `case` in a `switch` statement needs to be an integer (or a `char`, which is really just an integer), not a Boolean expression or other type."
        ]
        return (lines[0:2], response) if len(lines) >= 2 else (lines[0:1], response)

    # $ clang foo.c
    # /tmp/foo-1ce1b9.o: In function `main':
    # foo.c:12:15: error: if statement has empty body [-Werror,-Wempty-body]
    #   if (n > 0);
    #             ^
    matches = match(r"(if statement|while loop|for loop) has empty body", lines[0])
    if matches:
        response = [
            "Try removing the semicolon directly after the closing parentheses of the `{}` on line {} of `{}`.".format(matches.group[0],matches.line, matches.file)
        ]
        if len(lines) >= 2 and re.search(r"if\s*\(", lines[1]):
            return (lines[0:2], response)
        return (lines[0:1], response)

    # $ clang foo.c
    # round.c:17:5: error: ignoring return value of function declared with const attribute [-Werror,-Wunused-value]
    # round(cents);
    # ^~~~~ ~~~~~
    matches = match(r"ignoring return value of function declared with (.+) attribute", lines[0])
    if matches:
        function = caret_extract(lines[1:3])
        if function:
            response = [
                "You seem to be calling `{}` on line {} of `{}` but aren't using its return value.".format(function, matches.line, matches.file),
                "Did you mean to assign it to a variable?"
            ]
            return (lines[0:3], response)
        else:
            response = [
                "You seem to be calling a function on line {} of `{}` but aren't using its return value.".format(matches.line, matches.file),
                "Did you mean to assign it to a variable?"
            ]
            return (lines[0:1], response)

    # $ clang foo.c
    # /tmp/foo-1ce1b9.o: In function `main':
    # foo.c:5:12: error: implicit declaration of function 'get_int' is invalid in C99 [-Werror,-Wimplicit-function-declaration]
    #    int x = get_int();
    #            ^
    matches = match(r"implicit declaration of function '([^']+)' is invalid", lines[0])
    if matches:
        response = [
            "You seem to have an error in `{}` on line {}.".format(matches.file, matches.line),
            "By \"implicit declaration of function '{}'\", `clang` means that it doesn't recognize `{}`.".format(matches.group[0], matches.group[0])
        ]
        if matches.group[0] in ["eprintf", "get_char", "get_double", "get_float", "get_int", "get_long", "get_long_long", "get_string", "GetChar", "GetDouble", "GetFloat", "GetInt", "GetLong", "GetLongLong", "GetString"]:
            response.append("Did you forget to `#include <cs50.h>` (in which `{}` is declared) atop your file?".format(matches.group[0]))
        elif matches.group[0] in ["crypt"]:
            response.append("Did you forget to `#include <unistd.h>` (in which `{}` is declared) atop your file?".format(matches.group[0]))
        else:
            response.append("Did you forget to `#include` the header file in which `{}` is declared atop your file?".format(matches.group[0]))
            response.append("Did you forget to declare a prototype for `{}` atop `{}`?".format(matches.group[0], matches.file))

        if len(lines) >= 2 and re.search(matches.group[0], lines[1]):
            return (lines[0:2], response)
        return (lines[0:1], response)

    # $ clang foo.c
    # /tmp/foo-1ce1b9.o: In function `main':
    # foo.c:3:4: error: implicitly declaring library function 'printf' with type 'int (const char *, ...)' [-Werror]
    #    printf("hello, world!");
    #    ^
    matches = match(r"implicitly declaring library function '([^']+)'", lines[0])
    if matches:
        if (matches.group[0] in ["printf"]):
            response = ["Did you forget to `#include <stdio.h>` (in which `printf` is declared) atop your file?"]
        elif (matches.group[0] in ["malloc"]):
            response = ["Did you forget to `#include <stdlib.h>` (in which `malloc` is declared) atop your file?"]
        else:
            response = ["Did you forget to `#include` the header file in which `{}` is declared atop your file?".format(matches.group[0])]
        if len(lines) >= 2 and re.search(r"printf\s*\(", lines[1]):
            return (lines[0:2], response)
        return (lines[0:1], response)

    # $ clang foo.c
    # /tmp/foo-1ce1b9.o: In function `main':
    # foo.c:3:8: error: incompatible pointer to integer conversion initializing 'int' with an expression of type 'char [3]'
    #       [-Werror,-Wint-conversion]
    #    int x = "28";
    #        ^   ~~~~
    matches = match(r"incompatible (.+) to (.+) conversion", lines[0])
    if matches:
        response = [
            "By \"incompatible conversion\", `clang` means that you are assigning a value to a variable of a different type on line {} of `{}`. Try ensuring that your value is of type `{}`.".format(matches.line, matches.file, matches.group[1])
        ]
        if len(lines) >= 2 and re.search(r"=", lines[1]):
            return (lines[0:2], response)
        return (lines[0:1], response)

    # $ ./a.out
    # foo.c:7:5: runtime error: index 2 out of bounds for type 'int [2]'
    matches = match(r"index (-?\d+) out of bounds for type '.+'", lines[0])
    if matches:
        response = []
        if int(matches.group[0]) < 0:
            response.append("Looks like you're to access location {} of an array on line {} of `{}`, but that location is before the start of the array.".format(matches.group[0], matches.line, matches.file))
        else:
            response.append("Looks like you're to access location {} of an array on line {} of `{}`, but that location is past the end of the array.".format(matches.group[0], matches.line, matches.file, matches.group[0]))
        return (lines[0:1], response)

    # $ clang foo.c
    # /tmp/foo-1ce1b9.o: In function `main':
    # foo.c:5:19: error: format specifies type 'int' but the argument has type 'char *' [-Werror,-Wformat]
    #    printf("%d\n", "hello!");
    #            ~~     ^~~~~~~~
    #            %s
    # TODO: pattern match on argument's type
    matches = match(r"format specifies type '[^:]+' but the argument has type '[^:]+'", lines[0])
    if matches:
        response = [
            "Be sure to use the correct format code (e.g., `%i` for integers, `%f` for floating-point values, `%s` for strings, etc.) in your format string on line {} of `{}`.".format(matches.line, matches.file)
        ]
        if len(lines) >= 3 and re.search(r"\^", lines[2]):
            if len(lines) >= 4 and re.search(r"%", lines[3]):
                return (lines[0:4], response)
            return (lines[0:3], response)
        return (lines[0:1], response)

    # $ clang foo.c
    # foo.c:8:19: error: invalid '==' at end of declaration; did you mean '='?
    #    for(int i == 0; i < height; i++)
    #              ^~
    #              =
    matches = match(r"invalid '==' at end of declaration; did you mean '='?", lines[0])
    if matches:
        response = [
            "Looks like you may have used '==' (which is used for comparing two values for equality) instead of '=' (which is used to assign a value to a variable) on line {} of `{}`?".format(matches.line, matches.file)
        ]
        return (lines[0:1], response)

    # $ clang foo.c
    # /tmp/foo-1ce1b9.o: In function `main':
    # foo.c:1:2: error: invalid preprocessing directive
    # #incalude <stdio.h>
    #  ^
    matches = match(r"invalid preprocessing directive", lines[0])
    if matches:
        response = [
            "By \"invalid preprocesing directive\", `clang` means that you've used a preprocessor command on line {} (a command beginning with #) that is not recognized.".format(matches.file)
        ]
        if len(lines) >= 2:
            directive = re.search(r"^([^' ]+)", lines[1])
            if directive:
                response.append("Check to make sure that `{}` is a valid directive (like `#include`) and is spelled correctly.".format(directive.group(1)))
                return (lines[0:2], response)
        return (lines[0:1], response)

    # $ clang foo.c
    # /tmp/foo-1ce1b9.o: In function `main':
    # foo.c:3:1: error: 'main' must return 'int'
    # void main(void)
    # ^~~~
    # int
    matches = match(r"'main' must return 'int'", lines[0])
    if matches:
        response = [
            "Your `main` function (declared on line {} of `{}`) must have a return type `int`.".format(matches.line, matches.file)
        ]
        cur_type = caret_extract(lines[1:3])
        if len(lines) >= 3 and cur_type:
            response.append("Right now, it has a return type of `{}`.".format(cur_type))
            return (lines[0:3], response)
        return (lines[0:1], response)

    # $ clang foo.c
    # /tmp/foo-1ce1b9.o: In function `main':
    # foo.c:5:16: error: more '%' conversions than data arguments [-Werror,-Wformat]
    #    printf("%d %d\n", 28);
    #               ~^
    matches = match(r"more '%' conversions than data arguments", lines[0])
    if matches:
        response = [
            "You have too many format codes in your format string on line {} of `{}`.".format(matches.line, matches.file),
            "Be sure that the number of format codes equals the number of additional arguments."
        ]
        if len(lines) >= 2 and re.search(r"%", lines[1]):
            return (lines[0:2], response)
        return (lines[0:1], response)

    # $ clang foo.c
    # /tmp/foo-1ce1b9.o: In function `main':
    # foo.c:1:10: error: multiple unsequenced modifications to 'space' [-Werror,-Wunsequenced]
    #  space = space--;
    #        ~      ^
    matches = match(r"multiple unsequenced modifications to '(.*)'", lines[0])
    if matches:
        variable = matches.group[0]
        response = [
            "Looks like you're changing the variable `{}` multiple times in a row on line {} of `{}`.".format(variable, matches.line, matches.file)
        ]
        if len(lines) >= 2:
            file = matches.file
            line = matches.line
            matches = re.search(r"(--|\+\+)", lines[1])
            if matches:
                response.append("When using the `{}` operator, there is no need to assign the result to the variable. Try using just `{}{}` instead".format(matches.group(1), variable, matches.group(1)))
                return (lines[0:2], response)
        return (lines[0:1], response)

    # $ clang foo.c
    # foo.c:6:5: error: only one parameter on 'main' declaration [-Werror,-Wmain]
    # int main(int x)
    #     ^
    matches = match(r"only one parameter on 'main' declaration", lines[0])
    if matches:
        response = [
        "Looks like your declaration of `main` on line {} of `{}` isn't quite right. The declaration of `main` should be `int main(void)` or `int main(int argc, string argv[])` or some equivalent.".format(matches.line, matches.file)
    ]
        return (lines[0:1], response)

    # clang -ggdb3 -O0 -std=c11 -Wall -Werror -Wshadow    mario.c  -lcs50 -lm -o mario
    # mario.c:12:19: error: relational comparison result unused [-Werror,-Wunused-comparison]
    #     while (height < 0, height < 23);
    #            ~~~~~~~^~~
    # 1 error generated.
    # make: *** [mario] Error 1
    matches = match(r"relational comparison result unused", lines[0])
    if matches:
        response = [
            "Looks like you're comparing two values on line {} of `{}` but not using the result?".format(matches.line, matches.file)
        ]
        if len(lines) >= 3 and has_caret(lines[2]):
            return (lines[0:3], response)
        return (lines[0:1], response)

    # $ clang foo.c
    # /tmp/foo-1ce1b9.o: In function `main':
    # foo.c:6:14: error: result of comparison against a string literal is unspecified (use strncmp instead) [-Werror,-Wstring-compare]
    #     if (word < "twenty-eight")
    #              ^ ~~~~~~~~~~~~~~
    matches = match(r"result of comparison against a string literal is unspecified", lines[0])
    if matches:
        response = [
            "You seem to be trying to compare two strings on line {} of `{}`".format(matches.line, matches.file),
            "You can't compare two strings the same way you would compare two numbers (with `<`, `>`, etc.).",
            "Did you mean to compare two characters instead? If so, try using single quotation marks around characters instead of double quotation marks.",
            "If you need to compare two strings, try using the `strcmp` function declared in `string.h`."
        ]
        if len(lines) >= 3 and has_caret(lines[2]):
            return (lines[0:3], response)
        return (lines[0:1], response)

    # $ make caesar.c
    # clang -ggdb3 -O0 -std=c11 -Wall -Werror -Wshadow    caesar.c  -lcs50 -lm -o caesar
    # caesar.c:5:5: error: second parameter of 'main' (argument array) must be of type 'char **'
    # int main(int argc, int argv[])
    #     ^
    matches = match(r"second parameter of 'main' \(argument array\) must be of type 'char \*\*'", lines[0])
    if matches:
        response = [
            "Looks like your declaration of `main` isn't quite right.",
            "Be sure its second parameter is `string argv[]` or some equivalent!"
        ]
        return (lines[0:1], response)

    # fifteen.c:179:21: error: subscripted value is not an array, pointer, or vector
    # temp = board[d - 1][d - 2];
    #        ~~~~~^~~~~~
    # TODO: extract symbol
    matches = match(r"subscripted value is not an array, pointer, or vector", lines[0])
    if matches:
        response = [
            "Looks like you're trying to index into a variable as though it's an array, even though it isn't, on line {} of `{}`?".format(matches.line, matches.file)
        ]
        return (lines[0:1], response)

    # $ clang mario.c
    # mario.c:18:17: error: too many arguments to function call, expected 0, have 1
    #         hashtag(x);
    #         ~~~~~~~ ^
    matches = match(r"too many arguments to function call, expected (\d+), have (\d+)", lines[0])
    if matches:
        function = tilde_extract(lines[1:3]) if len(lines) >= 3 else None
        response = [
            "You seem to be passing in too many arguments to a function on line {} of `{}`.".format(matches.line, matches.file)
        ]
        if function:
            response.append("The function `{}`".format(function))
        else:
            response.append("The function")
        response[1] += " is supposed to take {} argument(s), but you're passing it {}.".format(matches.group[0], matches.group[1])
        response.append("Try providing {} fewer argument(s) to the function.".format(str(int(matches.group[1]) - int(matches.group[0]))))
        if function:
            return (lines[0:3], response)
        return (lines[0:1], response)

    # $ clang foo.c
    # /tmp/foo-1ce1b9.o: In function `main':
    # foo.c:3:1: error: type specifier missing, defaults to 'int' [-Werror,-Wimplicit-int]
    # square (int x) {
    # ^
    matches = match(r"type specifier missing, defaults to 'int'", lines[0])
    if matches:
        response = [
            "Looks like you're trying to declare a function on line {} of `{}`.".format(matches.line, matches.file),
            "Be sure, when declaring a function, to specify its return type just before its name."
        ]
        if len(lines) >= 3 and re.search(r"^\s*\^$", lines[2]):
            return (lines[0:3], response)
        return (lines[0:1], response)

    # water.c:9:21: error: unknown escape sequence '\ ' [-Werror,-Wunknown-escape-sequence]
    # printf("bottles: %i \ n", shower);
    #                     ^~
    matches = match(r"unknown escape sequence '\\ '", lines[0])
    if matches:
        response = [
            "Looks like you have a space immediately after a backslash on line {} of `{}` but shouldn't.".format(matches.line, matches.file),
        ]
        if len(lines) >= 3 and has_caret(lines[2]):
            response.append("Did you mean to escape some character?")
            return (lines[0:3], response)
        else:
            response.append("Did you mean to escape some character?")
            return (lines[0:1], response)

    # $ clang foo.c
    # /tmp/foo-1ce1b9.o: In function `main':
    # foo.c:6:10: error: using the result of an assignment as a condition without parentheses [-Werror,-Wparentheses]
    #    if (x = 28)
    #        ~~^~~~
    matches = match(r"using the result of an assignment as a condition without parentheses", lines[0])
    if matches:
        response = [
            "When checking for equality in the condition on line {} of `{}`, try using a double equals sign (`==`) instead of a single equals sign (`=`).".format(matches.line, matches.file)
        ]
        if len(lines) >= 2 and re.search(r"if\s*\(", lines[1]):
            return (lines[0:2], response)
        return (lines[0:1], response)

    # $ clang foo.c
    # /tmp/foo-1ce1b9.o: In function `main':
    # foo.c:5:4: error: use of undeclared identifier 'x'
    #    x = 28;
    #    ^
    matches = match(r"use of undeclared identifier '([^']+)'", lines[0])
    if matches:
        response = [
            "By \"undeclared identifier,\" `clang` means you've used a name `{}` on line {} of `{}` which hasn't been defined.".format(matches.group[0], matches.line, matches.file)
        ]
        if matches.group[0] in ["true", "false", "bool", "string"]:
            response.append("Did you forget to `#include <cs50.h>` (in which `{}` is defined) atop your file?".format(matches.group[0]))
        else:
            response.append("If you mean to use `{}` as a variable, make sure to declare it by specifying its type, and check that the variable name is spelled correctly.".format(matches.group[0]))
        if len(lines) >= 2 and re.search(matches.file, lines[1]):
            return (lines[0:2], response)
        return (lines[0:1], response)

    # $ clang foo.c
    # /tmp/foo-1ce1b9.o: In function `main':
    # foo.c:(.text+0x9): undefined reference to `get_int'
    matches = match(r"undefined reference to `([^']+)'", lines[0], raw=True)
    if matches:
        if matches.group[0] == "main":
            response = ["Did you try to compile a file that doesn't contain a `main` function?"]
        else:
            response = [
                "By \"undefined reference,\" `clang` means that you've called a function, `{}`, that doesn't seem to be implemented.".format(matches.group[0]),
                "If that function has, in fact, been implemented, odds are you've forgotten to tell `clang` to \"link\" against the file that implements `{}`.".format(matches.group[0])
            ]
            if matches.group[0] in ["eprintf", "get_char", "get_double", "get_float", "get_int", "get_long", "get_long_long", "get_string"]:
                response.append("Did you forget to compile with `-lcs50` in order to link against against the CS50 Library, which implements `{}`?".format(matches.group[0]))
            elif matches.group[0] in ["GetChar", "GetDouble", "GetFloat", "GetInt", "GetLong", "GetLongLong", "GetString"]:
                response.append("Did you forget to compile with `-lcs50` in order to link against against the CS50 Library, which implements `{}`?".format(matches.group[0]))
            elif matches.group[0] == "crypt":
                response.append("Did you forget to compile with -lcrypt in order to link against the crypto library, which implemens `crypt`?")
            else:
                response.append("Did you forget to compile with `-lfoo`, where `foo` is the library that defines `{}`?".format(matches.group[0]))
        return (lines[0:1], response)

    # $ clang foo.c
    # foo.c:18:1: error: unknown type name 'define'
    # define _XOPEN_SOURCE 500
    # ^
    matches = match(r"unknown type name 'define'", lines[0])
    if matches:
        response = [
            "If trying to define a constant on line {} of `{}`, be sure to use `#define` rather than just `define`.".format(matches.line, matches.file)
        ]
        return (lines[0:3], response) if len(lines) >= 3 else (lines[0:1], response)

    # $ clang foo.c
    # /tmp/foo-1ce1b9.o: In function `main':
    # foo.c:1:1: error: unknown type name 'include'
    # include <stdio.h>
    # ^
    matches = match(r"unknown type name 'include'", lines[0])
    if matches:
        response = [
            "If trying to include a header file on line {} of `{}`, be sure to use `#include` rather than just `include`.".format(matches.line, matches.file)
        ]
        return (lines[0:3], response) if len(lines) >= 3 else (lines[0:1], response)

    # $ clang foo.c
    # /tmp/foo-1ce1b9.o: In function `main':
    # foo.c:1:1: error: unknown type name 'bar'
    # bar baz
    # ^
    # TODO: check if baz has () after it so as to distinguish attempted variable declaration from function declaration
    matches = match(r"unknown type name '(.+)'", lines[0])
    if matches:
        response = [
            "You seem to be using `{}` on line {} of `{}` as though it's a type, even though it's not been defined as one.".format(matches.group[0], matches.line, matches.file),
        ]
        if (matches.group[0] == "bool"):
            response.append("Did you forget `#include <cs50.h>` or `#include <stdbool.h>` atop `{}`?".format(matches.file))
        elif (matches.group[0] == "size_t"):
            response.append("Did you forget `#include <string.h>` atop `{}`?".format(matches.file))
        elif (matches.group[0] == "string"):
            response.append("Did you forget `#include <cs50.h>` atop `{}`?".format(matches.file))
        else:
            response.append("Did you perhaps misspell `{}` or forget to `typedef` it?".format(matches.group[0]))
        return (lines[0:3], response) if len(lines) >= 3 else (lines[0:1], response)

    # $ clang foo.c
    # /tmp/foo-1ce1b9.o: In function `main':
    # foo.c:6:9: error: unused variable 'x' [-Werror,-Wunused-variable]
    #     int x = 28;
    #         ^
    matches = match(r"unused variable '([^']+)'", lines[0])
    if matches:
        response = [
            "It seems that the variable `{}` (delcared on line {} of `{}`) is never used in your program. Try either removing it altogether or using it.".format(matches.group[0], matches.line, matches.file)
        ]
        return (lines[0:1], response)

    # $ clang foo.c
    # /tmp/foo-1ce1b9.o: In function `main':
    # foo.c:6:20: error: variable 'x' is uninitialized when used here [-Werror,-Wuninitialized]
    #     printf("%d\n", x);
    #                    ^
    matches = match(r"variable '(.*)' is uninitialized when used here", lines[0])
    if matches:
        response = [
            "It looks like you're trying to use the variable `{}` on line {} of `{}`.".format(matches.group[0], matches.line, matches.file),
            "However, on that line, the variable `{}` doesn't have a value yet.".format(matches.group[0]),
            "Be sure to assign a value to `{}` before trying to access its value.".format(matches.group[0])
        ]
        if len(lines) >= 2 and re.search(matches.group[0], lines[1]):
            return (lines[0:2], response)
        return (lines[0:1], response)

    # $ clang -ggdb3 -O0 -std=c11 -Wall -Werror -Wshadow    water.c  -lcs50 -lm -o water
    # water.c:8:15: error: variable 'x' is uninitialized when used within its own initialization [-Werror,-Wuninitialized]
    # int x= 12*x;
    #     ~     ^
    matches = match(r"variable '(.+)' is uninitialized when used within its own initialization", lines[0])
    if matches:
        response = [
            "Looks like you have `{}` on both the left- and right-hand side of the `=` on line {} of `{}`, but `{}` doesn't yet have a value.".format(matches.group[0], matches.line, matches.file, matches.group[0]),
            "Be sure not to initialize `{}` with itself.".format(matches.group[0])
        ]
        if len(lines) >= 3 and re.search(r"^\s*~\s*\^\s*$", lines[2]):
            return (lines[0:3], response)
        return (lines[0:1], response)

    # $ clang foo.c
    # foo.c:6:10: error: void function 'f' should not return a value [-Wreturn-type]
    #          return 0;
    #          ^      ~
    matches = match(r"void function '(.+)' should not return a value", lines[0])
    if matches:
        value = tilde_extract(lines[1:3])
        if len(lines) >= 3 and value:
            response = [
                "It looks like your function, `{}`, is returning `{}` on line {} of `{}`, but its return type is `void`.".format(matches.group[0], value, matches.line, matches.file),
                "Are you sure you want to return a value?"
            ]
            return (lines[0:3], response)
        else:
            response = [
                "It looks like your function, `{}`, is returning a value on line {} of `{}`, but its return type is `void`.".format(matches.group[0], matches.line, matches.file),
                "Are you sure you want to return a value?"
            ]
            return (lines[0:1], response)

# Performs a regular-expression match on a particular clang error or warning message.
# The first capture group is the filename associated with the message.
# The second capture group is the line number associated with the message.
# set raw=True to search for a message that doesn't follow clang's typical error output format.
def match(expression, line, raw=False):
    query = r"^([^:\s]+):(\d+):\d+: (?:warning|(?:fatal |runtime )?error): " + expression
    if raw:
        query = expression
    matches = re.search(query, line)
    if matches:
        Match = namedtuple('Match', ['file', 'line', 'group'])
        if raw:
            return Match(file=None, line=None, group=matches.groups())
        else:
            return Match(file=matches.group(1), line=matches.group(2), group=matches.groups()[2:])

# extract the name of a variable above the ^
# by default, assumes that ^ is under the first character of the variable
# if left_aligned is set to False, ^ is under the next character after the variable
# if char is set to True, will extract just a single character
def caret_extract(lines, left_aligned=True, char=False):
    if len(lines) < 2 or not has_caret(lines[1]):
        return
    index = lines[1].index("^")

    if char and len(lines[0]) >= index + 1:
        return lines[0][index]

    if left_aligned:
        matches = re.match(r"^([A-Za-z0-9_]+)", lines[0][index:])
    else:
        matches = re.match(r"^.*?([A-Za-z0-9_]+)$", lines[0][:index])
    return matches.group(1) if matches else None

# returns true if line contains a caret diagnostic
def has_caret(line):
    return True if (re.search(r"^[ ~]*\^[ ~]*$", line)) else False

# extracts all characters above the first sequence of ~
def tilde_extract(lines):
    if len(lines) < 2 or not re.search(r"~", lines[1]):
        return
    start = lines[1].index("~")
    length = 1
    while len(lines[1]) > start + length and lines[1][start + length] == "~":
        length += 1
    if len(lines[0]) < start + length:
        return
    return lines[0][start:start+length]

# end help50 code

#
# Code below is executed from gdb.
# It prints details of the program state likely to be of interest to
# a beginner programmer
#


hash_define = collections.defaultdict(dict)
source = {}

def debug_print(level, *args, **kwargs):
    if debug >= level:
        kwargs['file'] = sys.stderr
        print(*args, **kwargs)

class Location():
    def __init__(self, filename, line_number, column='', function='', params='', variable=''):
        self.filename = filename
        self.line_number = int(line_number)
        self.column = column
        self.function = function
        self.params = params
        self.variable = variable
    def __str__(self):
        return "Location(%s,%s,column=%s,function=%s,params=%s,variable=%s)" % (self.filename, self.line_number, self.column, self.function, self.params, self.variable)
    def description(self):
        params = self.params
        if self.function == 'main' and params.startswith('argc=1,'):
            params = ''
        return "in %s(%s) at\n%s:%s: %s" % (self.function, params, self.filename, self.line_number, self.source_line())
    def long_description(self):
        params = self.params
        if self.function == 'main' and params.startswith('argc=1,'):
            params = ''
        if colorize_output:
            return "in %s(%s) in \033[31m%s\033[0m at \033[31mline %s\033[0m:\n\n" % (self.function, params, self.filename, self.line_number) + self.surrounding_source(markMiddle=True)
        else:
            return "in %s(%s) in %s at line %s:\n\n" % (self.function, params, self.filename, self.line_number) + self.surrounding_source(markMiddle=True)
    def source_line(self, clean=False):
        return fileline(self.filename, self.line_number, clean)
    def surrounding_source(self, radius=2, clean=False, markMiddle=False):
        source = ''
        for offset in range(-radius, radius+1):
            line = fileline(self.filename, self.line_number+offset, clean=clean)
            if markMiddle and offset == 0:
                line = re.sub(r'^ {0,3}', '-->', line)
                if colorize_output:
                    line = '\033[31m' + line + '\033[0m'
            source += line
        return source
    def is_user_location(self):
        if not re.match(r'^[a-zA-Z]', self.function): return False 
        if re.match(r'^/(usr|build)/', self.filename): return False 
        if re.match(r'^\?', self.filename): return False 
        return True
      
    
def fileline(filename, line_number, clean=False):
    line_number = int(line_number)
    if filename in source:
        if line_number < 0 or line_number > len(source[filename]):
            return ''
        if clean:
            return clean_c_source(source[filename][line_number - 1])
        return source[filename][line_number - 1]
    try:
        with open(filename) as f:
            source[filename] = f.readlines()
            for line in source[filename]:
                m = re.match(r'^\s*#\s*define\s*(\w+)\s*(.*\S)', line)
                if m:
                    hash_define[filename][m.group(1)] = (line.rstrip(), m.group(2))
        line = source[filename][line_number - 1].rstrip() + "\n"
        if clean:
            line = clean_c_source(line)
        return line
    except IOError:
        debug_print(1, "fileline error can not open: %s" % (filename))
    except IndexError:
        pass
    return ""

# remove comments and truncate strings & character constants to zero-length
def clean_c_source(c_source, leave_white_space=False):
    c_source = re.sub("\\[\"']", '', c_source)
    c_source = re.sub(r'".*?"', '', c_source)
    c_source = re.sub(r"'.*?'", '', c_source)
    c_source = re.sub(r'/[/\*].*', '', c_source)
    if leave_white_space:
        return c_source
    return c_source.strip() + "\n"

def gdb_execute(command):
    debug_print(2, 'gdb.execute:', command)
    str = gdb.execute(command, to_string=True)
    debug_print(2, 'gdb.execute:', '->', str)
    return str
    
def gdb_evaluate(expression):
    debug_print(1, 'gdb_evaluate:', expression,)
    value = gdb_execute('print %s' % expression)
    value = re.sub('^[^=]*=\s*', '', value).strip()
    debug_print(1, '->', value,)
    return value.strip()

def parse_gdb_stack_frame(line):
    # note don't match function names starting with _ these are not user functions
    m = re.match(
        r'^\s*#(?P<frame_number>\d+)\s+0x[0-9a-f]+\s+in+\s+'
        r'(?P<function>[a-zA-Z][^\s\(]*).*\((?P<params>.*)\)\s+at\s+'
        r'(?P<filename>[^\s:]+):(?P<line_number>\d+)\s*$',
            line)
    debug_print(1, 'parse_gdb_stack_frame', m != None, line)
    if m:
        filename = m.group('filename')
        if filename.startswith("/usr/") or filename.startswith("../sysdeps/"): 
            m = None
    return m
    
def gdb_set_frame():
    try:
        stack = gdb_execute('where')
        debug_print(1, "\nStack:\n",stack, "\n")
        stack_lines = stack.splitlines()
        frame = None
        for line in stack_lines:
            frame = parse_gdb_stack_frame(line)
            if frame and os.path.exists(frame.group('filename')):
                break
        if not frame:
            for line in reversed(stack_lines):
                frame = parse_gdb_stack_frame(line) or frame
        if not frame:
            debug_print(1, 'gdb_set_frame no frame number')
            return None
        gdb_execute('frame %s' % frame.group('frame_number'))
        return Location(frame.group('filename'), frame.group('line_number'), function=frame.group('function'), params=frame.group('params'))
    except:
        if debug: traceback.print_exc(file=sys.stderr)
    
def relevant_variables(c_source, arrays=[]):
    expressions = extract_expressions(c_source)
#    arrays=[r'[a-z][a-zA-Z0-9_]*']
#    debug_print(1, 'relevant_variables', arrays, c_source)
#    for array in arrays:
#        indices = extract_indices(array, c_source)
#        expressions += indices
    done = set(['NULL', 'char','int', 'double', 'while', 'if', 'else', 'for', 'while', 'return']) # avoid trying to evaluate types/keywords for efficency
    explanation = ''
    debug_print(1, 'relevant_variables expressions=', c_source, expressions)
    for expression in sorted(expressions, key=lambda e: (len(re.findall(r'\w+', e)), e)):
        try:
            expression = expression.strip()
            if expression in done: continue
            done.add(expression)
            if re.match(r'^-?\s*[\d\.]+$', expression): continue      # don't print(numbers)
            debug_print(1, 'expression:', expression)
            if re.search(r'[a-zA-Z0-9_]\s*\(', expression): continue  # don't evaluate function calls
            expression_type = gdb_execute('whatis %s' % expression)
            expression_type = re.sub(r'\s*type\s*=\s*', '',  expression_type).strip()
            debug_print(1, 'expresion_type=', expression_type)
            if re.search(r'\<|\)$', expression_type): continue 

            expression_value = gdb_evaluate(expression)

            if '_IO_FILE' in  expression_value: continue
            if expression_value == '<optimized out>': continue
            if expression_value == '<optimized out>': continue
            if len(expression_value) > 128: continue
            expression_value = re.sub(r'^0x[0-9a-f]+\s*(<.str>)?\s*"', '"', expression_value)
            if re.search(r'^\(.*\s+0x[0-9a-f]{4,}\s*$', expression_value): continue 
            expression_value = re.sub(r'^\s*\(\S+\s+\*\)\s*0x0\s*$', 'NULL', expression_value)
            if expression_type == 'char':
                m = re.match(r"^(-?\d+) '(.*)'$", expression_value)
                if m:
                    ascii = int(m.group(1))
                    if (0 < ascii < 9) or (13 < ascii < 32)  or (ascii == 127):
                         expression_value = '%d (non-printable ASCII character)' % ascii
                    elif ascii < 0 or ascii > 128:
                         expression_value = '%d (not valid ASCII)' % ascii
                    elif ascii == 0:
                         expression_value = "0 = '\\0'"
                    else:
                         expression_value = "%s = '%s'" % m.groups()
            expression_value = re.sub(r"'\000'", r"'\\0'", expression_value)
            explanation +=  "%s = %s\n" % (expression, expression_value)
        except RuntimeError as e:
            debug_print(1, 'print_variables_expressions: RuntimeError', e)
            pass
    if explanation:
        prefix = 'Values when execution stopped:'
        if colorize_output:
            prefix = '\033[34m' + prefix + '\033[0m'
        explanation = prefix + '\n\n' + explanation
    return explanation
    

def balance_bracket(str, depth=0):
#    debug_print(1, 'balance_bracket(%s, %s)' % (str, depth))
    if not str:
        return ""
    elif str[0] == ']' or str[0] == ')':
        depth -= 1
    elif str[0] == '[' or str[0] == '(':
        depth += 1
    if depth < 0 and (len(str) == 1 or str[1] != '['):
        return ""
    return str[0] +  balance_bracket(str[1:], depth)

    
def extract_expressions(c_source):
    expressions = []
    # match declaration
    m = re.match(r'[a-z][a-zA-Z0-9_]*\s+[a-z][a-zA-Z0-9_]*\s*\[(.*)', c_source, re.DOTALL)
    if m:
         return extract_expressions(m.group(1))
    m = re.match(r'([a-z][a-zA-Z0-9_]*)\s*\[(.*)', c_source, re.DOTALL)
    if m:
        index = balance_bracket(m.group(2))
        if index:
            expressions = [m.group(1), index, m.group(1) + '[' + index + ']']
        remainder = m.group(2)
    else:
        m = re.match(r'([a-zA-Z][a-zA-Z0-9_]*)(.*)', c_source, re.DOTALL)
        if m:
            expressions = [m.group(1)]
            remainder = m.group(2)
        else:
            m = re.match(r'^[^a-zA-Z]+(.*)', c_source, re.DOTALL)
            if m:
                remainder = m.group(1)
            else:
                return []
    return expressions + extract_expressions(remainder)
    
def explain_signal(signal_number):
    if signal_number == signal.SIGINT:
        return "Execution was interrupted"
    elif signal_number == signal.SIGFPE:
        return 'Execution stopped by an arithmetic error.\nOften this is caused by division (or %) by zero.'
    elif signal_number == signal.SIGXCPU:
        return "Execution stopped by a CPU time limit."
    elif signal_number == signal.SIGXFSZ:
        return "Execution stopped because too much data written."
    else:
        return "Execution terminated by signal %s" % signal_number

def explain_location(loc):
    if not isinstance(loc, Location):
        return "Execution stopped at '%s'" % (loc)
    else:
        return 'Execution stopped here ' + loc.long_description()

def explain_error():
    #subprocess.call("echo explain_error_gdb.py starting >/dev/tty", shell=True)
    debug_print(1, 'explain_error() starting')
    pid = None
    # file descriptor 3 is a dup of stderr (see below)
    # stdout & stderr have been diverted to /dev/null
    output_stream = os.fdopen(3, "w")
    try:
        signal.signal(signal.SIGINT, handler)
        pid = int(os.environ.get('DCC_PID', 0))
        if 'DCC_VALGRIND_ERROR' in os.environ:
            debug_print(1, 'attaching gdb to valgrind', pid)
            gdb.execute('target remote | vgdb --pid=%d' % pid)
        else:
            debug_print(1, 'attaching gdb to ', pid)
            gdb.execute('attach %s' % pid)
        print(file=output_stream)
        loc = gdb_set_frame()
        signal_number = int(os.environ.get('DCC_SIGNAL', signal.SIGABRT))
        if signal_number != signal.SIGABRT:
             print(explain_signal(signal_number), file=output_stream)
        elif "DCC_ASAN_ERROR" in os.environ:
            if loc:
                print("%s:%d" % (loc.filename, loc.line_number), end=' ', file=output_stream)
            print("runtime error - illegal array, pointer or other operation", file=output_stream)
        elif os.environ.get('DCC_SANITIZER', '') == 'memory':
            if loc:
                print("%s:%d" % (loc.filename, loc.line_number), end=' ', file=output_stream)
            print("runtime error - uninitialized variable used", file=output_stream)
        if loc:
            print(explain_location(loc), file=output_stream)
            print(relevant_variables(loc.surrounding_source(clean=True)), file=output_stream)
        gdb.flush(gdb.STDOUT)
        gdb.flush(gdb.STDERR)
    except gdb.error as e:
        if 'ptrace' in str(e).lower() and os.path.exists('/.dockerenv'):
            print('\ndcc : can not provide information about variables because docker not run with --cap-add=SYS_PTRACE\n' , file=output_stream)
        elif debug:
            traceback.print_exc(file=output_stream)
        else:
            print(e, file=output_stream)    
        sys.exit(1)
    except:
        if debug: traceback.print_exc(file=output_stream)
        sys.exit(1)

#
# ensure the program compiled with dcc terminates after error
#
def kill_program():
    if 'DCC_PID' in os.environ:
        try:
            os.kill(int(os.environ['DCC_PID']), signal.SIGPIPE)
            os.kill(int(os.environ['DCC_PID']), signal.SIGKILL)
        except ProcessLookupError:
            pass
    sys.exit(1)

def handler(signum, frame):
    if debug: print >>sys.stderr, 'signal caught'
    kill_program()
    
def run_gdb():
    if colorize_output:
        os.environ['DCC_COLORIZE_OUTPUT'] = 'true'
    os.environ['DCC_RUN_INSIDE_GDB'] = 'true'
    os.environ['PATH'] = '/bin:/usr/bin:/usr/local/bin:/sbin:/usr/sbin:' + os.environ.get('PATH', '')
    if not search_path('gdb'):
        print('\ngdb not available to print variable values\n', file=sys.stderr)
        kill_program()
        return
    command = ["gdb", "--nx", "--batch", "-ex", "python exec(open('%s').read())" % dcc_path, os.environ['DCC_BINARY']]
    debug_print(1, 'running:', command)
    # gdb puts confusing messages on stderr & stdout  so send these to /dev/null
    # and use file descriptor 3 for our messages
    os.dup2(2, 3)
    if debug:
        p = subprocess.Popen(command, stdin=subprocess.DEVNULL, close_fds=False)
    else:
        p = subprocess.Popen(command, stdin=subprocess.DEVNULL, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, close_fds=False)
    p.communicate()
    kill_program()
    
if __name__ == '__main__':
    signal.signal(signal.SIGINT, handler)
    if debug: print(sys.argv, 'DCC_RUN_INSIDE_GDB="%s" DCC_SANITIZER="%s"' % (os.environ.get('DCC_RUN_INSIDE_GDB', ''), os.environ.get('DCC_PID', '')))
    if not sys.argv[1:] and 'DCC_RUN_INSIDE_GDB' in os.environ:
        # we are invoked by gdb 
        import gdb
        explain_error()
        gdb_execute('call _exit()')
        gdb_execute('quit')
        kill_program()
    elif not sys.argv[1:] and 'DCC_PID' in os.environ:
        # we are invoked by the binary because an eror has occurred
        run_gdb()
    elif sys.argv[1:] == ['--watch-stdin-for-valgrind-errors']:
        # valgrind is being used - we have been invoked viq the binary to watch for valgrind errors
        # which have been directed to our stdin
        while True:
            line = sys.stdin.readline()
            if not line:
                break
            debug_print(1, 'valgrind: ', line)
            if 'vgdb me' in line:
                if colorize_output:
                    os.environ['DCC_VALGRIND_ERROR'] = 'Runtime error: \033[31muninitialized variable accessed.\033[0m'
                else:
                    os.environ['DCC_VALGRIND_ERROR'] = 'Runtime error: uninitialized variable accessed.'
                print('\n'+os.environ['DCC_VALGRIND_ERROR'], file=sys.stderr)
                sys.stderr.flush()
                run_gdb()
    elif sys.argv[1:] == ['--watch-stdin-for-clang-errors']:
        # valgrind is being used - we have been invoked vi the binary to watch for valgrind errors
        # which have been directed to our stdin
        while True:
            line = sys.stdin.readline()
            if not line:
                break
            sys.out.write(line)
    else:
        # we are invoked by user to compile a program
        os.environ['PATH'] = os.path.dirname(os.path.realpath(sys.argv[0])) + ':/bin:/usr/bin:/usr/local/bin:/sbin:/usr/sbin:' + os.environ.get('PATH', '') 
        compile()
